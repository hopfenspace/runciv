/* tslint:disable */
/* eslint-disable */
/**
 * runciv
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: git@omikron.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ApiErrorResponse,
  CreateLobbyRequest,
  CreateLobbyResponse,
  GetLobbiesResponse,
  GetLobbyResponse,
  JoinLobbyRequest,
  StartGameResponse,
} from '../models';
import {
    ApiErrorResponseFromJSON,
    ApiErrorResponseToJSON,
    CreateLobbyRequestFromJSON,
    CreateLobbyRequestToJSON,
    CreateLobbyResponseFromJSON,
    CreateLobbyResponseToJSON,
    GetLobbiesResponseFromJSON,
    GetLobbiesResponseToJSON,
    GetLobbyResponseFromJSON,
    GetLobbyResponseToJSON,
    JoinLobbyRequestFromJSON,
    JoinLobbyRequestToJSON,
    StartGameResponseFromJSON,
    StartGameResponseToJSON,
} from '../models';

export interface CloseLobbyRequest {
    uuid: string;
}

export interface CreateLobbyOperationRequest {
    createLobbyRequest: CreateLobbyRequest;
}

export interface GetLobbyRequest {
    uuid: string;
}

export interface JoinLobbyOperationRequest {
    uuid: string;
    joinLobbyRequest: JoinLobbyRequest;
}

export interface KickPlayerFromLobbyRequest {
    lobbyUuid: string;
    playerUuid: string;
}

export interface LeaveLobbyRequest {
    uuid: string;
}

export interface StartGameRequest {
    uuid: string;
}

/**
 * 
 */
export class LobbiesApi extends runtime.BaseAPI {

    /**
     * Close an open lobby  This endpoint can only be used by the lobby owner. For joined users, see `POST /lobbies/{uuid}/leave`.  On success, all joined players will receive a [WsMessage::LobbyClosed] message via websocket.
     * Close an open lobby
     */
    async closeLobbyRaw(requestParameters: CloseLobbyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling closeLobby.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v2/lobbies/{uuid}`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Close an open lobby  This endpoint can only be used by the lobby owner. For joined users, see `POST /lobbies/{uuid}/leave`.  On success, all joined players will receive a [WsMessage::LobbyClosed] message via websocket.
     * Close an open lobby
     */
    async closeLobby(requestParameters: CloseLobbyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.closeLobbyRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new lobby  If you are already in another lobby, an error is returned. `max_players` must be between 2 and 34 (inclusive). If `password` is an empty string, an error is returned. If you are not connected via websocket, an error is returned.  You are placed in the lobby and in the corresponding chatroom
     * Create a new lobby
     */
    async createLobbyRaw(requestParameters: CreateLobbyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateLobbyResponse>> {
        if (requestParameters.createLobbyRequest === null || requestParameters.createLobbyRequest === undefined) {
            throw new runtime.RequiredError('createLobbyRequest','Required parameter requestParameters.createLobbyRequest was null or undefined when calling createLobby.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v2/lobbies`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateLobbyRequestToJSON(requestParameters.createLobbyRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CreateLobbyResponseFromJSON(jsonValue));
    }

    /**
     * Create a new lobby  If you are already in another lobby, an error is returned. `max_players` must be between 2 and 34 (inclusive). If `password` is an empty string, an error is returned. If you are not connected via websocket, an error is returned.  You are placed in the lobby and in the corresponding chatroom
     * Create a new lobby
     */
    async createLobby(requestParameters: CreateLobbyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateLobbyResponse> {
        const response = await this.createLobbyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves all open lobbies.  If `password` is `true`, the lobby is secured by a user-set password
     * Retrieves all open lobbies.
     */
    async getAllLobbiesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetLobbiesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v2/lobbies`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetLobbiesResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves all open lobbies.  If `password` is `true`, the lobby is secured by a user-set password
     * Retrieves all open lobbies.
     */
    async getAllLobbies(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetLobbiesResponse> {
        const response = await this.getAllLobbiesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves an open lobbies.  If `password` is `true`, the lobby is secured by a user-set password
     * Retrieves an open lobbies.
     */
    async getLobbyRaw(requestParameters: GetLobbyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetLobbyResponse>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getLobby.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v2/lobbies/{uuid}`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetLobbyResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves an open lobbies.  If `password` is `true`, the lobby is secured by a user-set password
     * Retrieves an open lobbies.
     */
    async getLobby(requestParameters: GetLobbyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetLobbyResponse> {
        const response = await this.getLobbyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Join an existing lobby  The executing user must not be the owner of a lobby or member of a lobby. To be placed in a lobby, a active websocket connection is required.  As a lobby might be protected by password, the optional parameter `password` may be specified. If the provided password was incorrect, the error [ApiError::MissingPrivileges] is returned. If the lobby isn\'t protected, but a password was found in the request, it is ignored.  If the lobby is already full, a [ApiError::LobbyFull] error is returned.  On success, all players that were in the lobby before, are notified about the new player with a [WsMessage::LobbyJoin] message.
     * Join an existing lobby
     */
    async joinLobbyRaw(requestParameters: JoinLobbyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling joinLobby.');
        }

        if (requestParameters.joinLobbyRequest === null || requestParameters.joinLobbyRequest === undefined) {
            throw new runtime.RequiredError('joinLobbyRequest','Required parameter requestParameters.joinLobbyRequest was null or undefined when calling joinLobby.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v2/lobbies/{uuid}/join`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: JoinLobbyRequestToJSON(requestParameters.joinLobbyRequest),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Join an existing lobby  The executing user must not be the owner of a lobby or member of a lobby. To be placed in a lobby, a active websocket connection is required.  As a lobby might be protected by password, the optional parameter `password` may be specified. If the provided password was incorrect, the error [ApiError::MissingPrivileges] is returned. If the lobby isn\'t protected, but a password was found in the request, it is ignored.  If the lobby is already full, a [ApiError::LobbyFull] error is returned.  On success, all players that were in the lobby before, are notified about the new player with a [WsMessage::LobbyJoin] message.
     * Join an existing lobby
     */
    async joinLobby(requestParameters: JoinLobbyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.joinLobbyRaw(requestParameters, initOverrides);
    }

    /**
     * Kick a player from an open lobby  This endpoint can only be used by the lobby owner.  All players in the lobby as well as the kick player will receive a [WsMessage::LobbyKick] message via websocket on success.
     * Kick a player from an open lobby
     */
    async kickPlayerFromLobbyRaw(requestParameters: KickPlayerFromLobbyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.lobbyUuid === null || requestParameters.lobbyUuid === undefined) {
            throw new runtime.RequiredError('lobbyUuid','Required parameter requestParameters.lobbyUuid was null or undefined when calling kickPlayerFromLobby.');
        }

        if (requestParameters.playerUuid === null || requestParameters.playerUuid === undefined) {
            throw new runtime.RequiredError('playerUuid','Required parameter requestParameters.playerUuid was null or undefined when calling kickPlayerFromLobby.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v2/lobbies/{lobby_uuid}/{player_uuid}`.replace(`{${"lobby_uuid"}}`, encodeURIComponent(String(requestParameters.lobbyUuid))).replace(`{${"player_uuid"}}`, encodeURIComponent(String(requestParameters.playerUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Kick a player from an open lobby  This endpoint can only be used by the lobby owner.  All players in the lobby as well as the kick player will receive a [WsMessage::LobbyKick] message via websocket on success.
     * Kick a player from an open lobby
     */
    async kickPlayerFromLobby(requestParameters: KickPlayerFromLobbyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.kickPlayerFromLobbyRaw(requestParameters, initOverrides);
    }

    /**
     * Leave an open lobby  This endpoint can only be used by joined users. For the lobby owner, you want to use `DELETE /lobbies/{uuid}`.  All players in the lobby will receive a [WsMessage::LobbyLeave] message via websocket on success.
     * Leave an open lobby
     */
    async leaveLobbyRaw(requestParameters: LeaveLobbyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling leaveLobby.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v2/lobbies/{uuid}/leave`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Leave an open lobby  This endpoint can only be used by joined users. For the lobby owner, you want to use `DELETE /lobbies/{uuid}`.  All players in the lobby will receive a [WsMessage::LobbyLeave] message via websocket on success.
     * Leave an open lobby
     */
    async leaveLobby(requestParameters: LeaveLobbyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.leaveLobbyRaw(requestParameters, initOverrides);
    }

    /**
     * Start a game from an existing lobby.  The executing user must be the owner of the lobby.  The lobby is deleted in the process, a new chatroom is created and all messages from the lobby chatroom are attached to the game chatroom.  This will invoke a [WsMessage::GameStarted] message that is sent via websocket to all members of the lobby to inform them which lobby was started. It also contains the the new and old chatroom uuids to make mapping for the clients easier.  After the game started, the lobby owner must use the `PUT /api/v2/games/{uuid}` endpoint to upload the initial game state.  **Note**: This behaviour is subject to change. The server should be set the order in which players are allowed to make their turns. This allows the server to detect malicious players trying to update the game state before its their turn.
     * Start a game from an existing lobby.
     */
    async startGameRaw(requestParameters: StartGameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StartGameResponse>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling startGame.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v2/lobbies/{uuid}/start`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StartGameResponseFromJSON(jsonValue));
    }

    /**
     * Start a game from an existing lobby.  The executing user must be the owner of the lobby.  The lobby is deleted in the process, a new chatroom is created and all messages from the lobby chatroom are attached to the game chatroom.  This will invoke a [WsMessage::GameStarted] message that is sent via websocket to all members of the lobby to inform them which lobby was started. It also contains the the new and old chatroom uuids to make mapping for the clients easier.  After the game started, the lobby owner must use the `PUT /api/v2/games/{uuid}` endpoint to upload the initial game state.  **Note**: This behaviour is subject to change. The server should be set the order in which players are allowed to make their turns. This allows the server to detect malicious players trying to update the game state before its their turn.
     * Start a game from an existing lobby.
     */
    async startGame(requestParameters: StartGameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StartGameResponse> {
        const response = await this.startGameRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
